1) JAVA SUBSTRING 
   PROBLEM STATEMENT
   ------------------
We define the following:

A subarray of an -element array is an array composed from a contiguous block of the original array's elements. For example, if , then the subarrays are , , , , , and . Something like  would not be a subarray as it's not a contiguous subsection of the original array.
The sum of an array is the total sum of its elements.
An array's sum is negative if the total sum of its elements is negative.
An array's sum is positive if the total sum of its elements is positive.
Given an array of  integers, find and print its number of negative subarrays on a new line.

Input Format

The first line contains a single integer, , denoting the length of array .
The second line contains  space-separated integers describing each respective element, , in array .

Constraints

Output Format

Print the number of subarrays of  having negative sums.

Sample Input

5
1 -2 4 -5 1
Sample Output

9
       SOLUTION
   ------------------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int n =sc.nextInt();
        int [] arr =new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int count=0;
        for(int i=0;i<n;i++){
            int sum =0;
            for(int j=i;j<n;j++){
                sum =sum+arr[j];
                if(sum<0)
                 count++;
            }
        }
        System.out.print(count);
    }
}

2)  JAVA ARRAYLIST
   PROBLEM STATEMENT
   -----------------
Sometimes it's better to use dynamic size arrays. Java's Arraylist can provide you this feature. 
Try to solve this problem using Arraylist.

You are given  lines. In each line there are zero or more integers. You need to answer a few queries where 
you need to tell the number located in  position of  line.

Take your input from System.in.

Input Format
The first line has an integer . In each of the next  lines there will be an integer  denoting number of integers on that line and then there will be  space-separated integers. In the next line there will be an integer  denoting number of queries. Each query will consist of two integers  and .

Constraints

Each number will fit in signed integer.
Total number of integers in  lines will not cross .

Output Format
In each line, output the number located in  position of  line. If there is no such position, just print "ERROR!"

Sample Input

5
5 41 77 74 22 44
1 12
4 37 34 36 52
0
3 20 22 33
5
1 3
3 4
3 1
4 3
5 5
Sample Output

74
52
37
ERROR!
ERROR!
    SOLUTION
    --------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner sc = new Scanner(System.in);
        int n =sc.nextInt();
        ArrayList<ArrayList<Integer>> al1 = new ArrayList<ArrayList<Integer>>();
        for(int i=0;i<n;i++){
            int d =sc.nextInt();
            ArrayList<Integer> al = new ArrayList<Integer>();
            for(int j=0;j<d;j++){
                int num =sc.nextInt();
                al.add(num);
            }
            al1.add(al);
        }
        int q = sc.nextInt();
        for(int i=0;i<q;i++){
            int x = sc.nextInt();//line
            int y = sc.nextInt();//position
            if(x>al1.size() || y>al1.get(x-1).size()){
                System.out.println("ERROR!");
            }
            else {
                System.out.println(al1.get(x-1).get(y-1));
            }
        }
    }
}

        Java Dequeue
        -------------
import java.util.*;

public class test {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the standard input stream
        Scanner in = new Scanner(System.in);
        
        // Initialize a deque (double-ended queue) to store integers
        Deque<Integer> deque = new ArrayDeque<>();
        
        // Read the size of the input array (n) and the size of the sliding window (m)
        int n = in.nextInt(); // Number of elements in the input array
        int m = in.nextInt(); // Size of the sliding window
        
        // Initialize a HashSet to store unique integers encountered in the sliding window
        HashSet<Integer> hs = new HashSet<>();
        
        // Initialize a variable to keep track of the maximum number of unique integers encountered
        int max = -1;
        
        // Iterate over the input array elements
        for (int i = 0; i < n; i++) {
            // Read an integer from the input
            int num = in.nextInt();
            
            // Add the integer to both the deque and the hash set
            hs.add(num); // Add the number to the HashSet to track unique numbers
            deque.add(num); // Add the number to the deque
            
            // Check if the size of the deque equals the size of the sliding window
            if (deque.size() == m) {
                // Check if the size of the HashSet is greater than the current maximum
                if (hs.size() > max) {
                    // Update the maximum if needed
                    max = hs.size(); // Update the maximum unique number count
                }
                
                // Remove the first element from the deque
                int first = (int) deque.remove(); // Remove the oldest number from the deque
                
                // Check if the removed element is still present in the deque
                if (!deque.contains(first)) {
                    // If the removed element is not present in the deque anymore, remove it from the HashSet
                    hs.remove(first); // Remove the oldest number from the HashSet
                }
            }
        }
        
        // Print the maximum number of unique integers encountered in any sliding window
        System.out.println(max);
    }
}

3)  JAVA Inheritance 2
   PROBLEM STATEMENT
   -----------------
Write the following code in your editor below:

A class named Arithmetic with a method named add that takes  integers as parameters and returns an integer denoting their sum.
A class named Adder that inherits from a superclass named Arithmetic.
Your classes should not be be .

Input Format

You are not responsible for reading any input from stdin; a locked code stub will test your submission by calling the add method on an Adder object and passing it  integer parameters.

Output Format

You are not responsible for printing anything to stdout. Your add method must return the sum of its parameters.

Sample Output

The main method in the Solution class above should print the following:

My superclass is: Arithmetic
42 13 20

    SOLUTION
    --------
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;
 class Arithmetic extends Solution {
    int add(int a,int b){
        a =a+b;
        return a;
    }
}
class Adder extends Arithmetic {
    
}
//Write your code here

public class Solution{
    public static void main(String []args){
        // Create a new Adder object
        Adder a = new Adder();
        
        // Print the name of the superclass on a new line
        System.out.println("My superclass is: " + a.getClass().getSuperclass().getName());	
        
        // Print the result of 3 calls to Adder's `add(int,int)` method as 3 space-separated integers:
        System.out.print(a.add(10,32) + " " + a.add(10,3) + " " + a.add(10,10) + "\n");
     }
}

4)  JAVA Abstract class
   PROBLEM STATEMENT
   -----------------
A Java abstract class is a class that can't be instantiated. That means you cannot create new instances of an abstract class. It works as a base for subclasses. You should learn about Java Inheritance before attempting this challenge.

Following is an example of abstract class:

abstract class Book{
    String title;
    abstract void setTitle(String s);
    String getTitle(){
        return title;
    }
}
If you try to create an instance of this class like the following line you will get an error:

Book new_novel=new Book(); 
You have to create another class that extends the abstract class. Then you can create an instance of the new class.

Notice that setTitle method is abstract too and has no body. That means you must implement the body of that method in the child class.

In the editor, we have provided the abstract Book class and a Main class. In the Main class, we created an instance of a class called MyBook. Your task is to write just the MyBook class.

Your class mustn't be public.

Sample Input

A tale of two cities
Sample Output

The title is: A tale of two cities
   SOLUTION
   ---------
import java.util.*;

// Abstract class Book
abstract class Book {
    String title;

    // Abstract method
    abstract void setTitle(String s);

    // Concrete method
    String getTitle() {
        return title;
    }
}

// Concrete class MyBook
class MyBook extends Book {
    // Implementing the abstract method setTitle
    void setTitle(String s) {
        this.title = s;
    }
}

// Main class with the main method
public class Main {
    public static void main(String[] args) {
        // Scanner object to read input from user
        Scanner sc = new Scanner(System.in);

        // Read the title from user input
        System.out.print("Enter the book title: ");
        String title = sc.nextLine();

        // Create an instance of MyBook
        MyBook new_novel = new MyBook();

        // Set the title of the book
        new_novel.setTitle(title);

        // Print the title of the book
        System.out.println("The title is: " + new_novel.getTitle());

        // Close the scanner
        sc.close();
    }
}

5)  JAVA Interface 
   PROBLEM STATEMENT
   -----------------
A Java interface can only contain method signatures and fields. The interface can be used to achieve polymorphism. In this problem, you will practice your knowledge on interfaces.

You are given an interface AdvancedArithmetic which contains a method signature int divisor_sum(int n). You need to write a class called MyCalculator which implements the interface.

divisorSum function just takes an integer as input and return the sum of all its divisors. For example divisors of 6 are 1, 2, 3 and 6, so divisor_sum should return 12. The value of n will be at most 1000.

Read the partially completed code in the editor and complete it. You just need to write the MyCalculator class only. Your class shouldn't be public.

Sample Input

6
Sample Output

I implemented: AdvancedArithmetic
12
Explanation

Divisors of 6 are 1,2,3 and 6. 1+2+3+6=12.

   SOLUTION
   ---------
import java.util.*;
interface AdvancedArithmetic{
  int divisor_sum(int n);
}

class MyCalculator implements AdvancedArithmetic {
    @Override
    public int divisor_sum(int n){
        int temp =n/2;
        int sum=0;
        for(int i=1;i<=temp;i++){
            if(n%i==0){
                sum = sum + i;
            }
        }
        return (sum+n);
    }
}
//Write your code here

class Solution{
    public static void main(String []args){
        MyCalculator my_calculator = new MyCalculator();
        System.out.print("I implemented: ");
        ImplementedInterfaceNames(my_calculator);
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.print(my_calculator.divisor_sum(n) + "\n");
      	sc.close();
    }
    /*
     *  ImplementedInterfaceNames method takes an object and prints the name of the interfaces it implemented
     */
    static void ImplementedInterfaceNames(Object o){
        Class[] theInterfaces = o.getClass().getInterfaces();
        for (int i = 0; i < theInterfaces.length; i++){
            String interfaceName = theInterfaces[i].getName();
            System.out.println(interfaceName);
        }
    }
}

6)  JAVA Method Overriding
   PROBLEM STATEMENT
   -----------------
When a subclass inherits from a superclass, it also inherits its methods; however, it can also override the superclass methods (as well as declare and implement new ones). Consider the following Sports class:

class Sports{
    String getName(){
        return "Generic Sports";
    }
    void getNumberOfTeamMembers(){
        System.out.println( "Each team has n players in " + getName() );
    }
}
Next, we create a Soccer class that inherits from the Sports class. We can override the getName method and return a different, subclass-specific string:

class Soccer extends Sports{
    @Override
    String getName(){
        return "Soccer Class";
    }
}
Note: When overriding a method, you should precede it with the @Override annotation. The parameter(s) and return type of an overridden method must be exactly the same as those of the method inherited from the supertype.

Task
Complete the code in your editor by writing an overridden getNumberOfTeamMembers method that prints the same statement as the superclass' getNumberOfTeamMembers method, except that it replaces  with  (the number of players on a Soccer team).

Output Format

When executed, your completed code should print the following:

Generic Sports
Each team has n players in Generic Sports
Soccer Class
Each team has 11 players in Soccer Class

   SOLUTION
   ---------

import java.util.*;
class Sports{

    String getName(){
        return "Generic Sports";
    }
  
    void getNumberOfTeamMembers(){
        System.out.println( "Each team has n players in " + getName() );
    }
}

class Soccer extends Sports{
    @Override
    String getName(){
        return "Soccer Class";
    }
    void getNumberOfTeamMembers(){
        System.out.println( "Each team has 11 players in " + getName() );
    }
    // Write your overridden getNumberOfTeamMembers method here

}

public class Solution{
	
    public static void main(String []args){
        Sports c1 = new Sports();
        Soccer c2 = new Soccer();
        System.out.println(c1.getName());
        c1.getNumberOfTeamMembers();
        System.out.println(c2.getName());
        c2.getNumberOfTeamMembers();
	}
}

6)  JAVA List
   PROBLEM STATEMENT
   -----------------
For this problem, we have  types of queries you can perform on a List:

Insert  at index :

Insert
x y
Delete the element at index :

Delete
x
Given a list, , of  integers, perform  queries on the list. Once all queries are completed, print the modified list as a single line of space-separated integers.

Input Format

The first line contains an integer,  (the initial number of elements in ).
The second line contains  space-separated integers describing .
The third line contains an integer,  (the number of queries).
The  subsequent lines describe the queries, and each query is described over two lines:

If the first line of a query contains the String Insert, then the second line contains two space separated integers , and the value  must be inserted into  at index .
If the first line of a query contains the String Delete, then the second line contains index , whose element must be deleted from .
Constraints



Each element in is a 32-bit integer.
Output Format

Print the updated list  as a single line of space-separated integers.

Sample Input

5
12 0 1 78 12
2
Insert
5 23
Delete
0
Sample Output

0 1 78 12 23
Explanation


 Insert 23 at index .

 Delete the element at index .

Having performed all  queries, we print  as a single line of space-separated integers.

   SOLUTION
   ---------

import java.util.*;

public class Solution {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        ArrayList<Integer> li = new ArrayList<Integer>();
        for(int i = 0; i < n; i++) {
            li.add(s.nextInt());
        }
        int q = s.nextInt();
        for(int i = 0; i < q; i++) {
            String query = s.next();
            if(query.equals("Insert")) {
                int x = s.nextInt();
                int y = s.nextInt();
                if(x >= 0 && x <= li.size()) {
                    li.add(x, y);
                }
            } else {
                int x = s.nextInt();
                li.remove(x);
            }
        }
        for(Integer num : li) {
            System.out.print(num + " ");
        }
    }
}

6)  JAVA Stack
   PROBLEM STATEMENT
   -----------------
A string containing only parentheses is balanced if the following is true: 1. if it is an empty string 2. if A and B are correct, AB is correct, 3. if A is correct, (A) and {A} and [A] are also correct.

Examples of some correctly balanced strings are: "{}()", "[{()}]", "({()})"

Examples of some unbalanced strings are: "{}(", "({)}", "[[", "}{" etc.

Given a string, determine if it is balanced or not.

Input Format

There will be multiple lines in the input file, each having a single non-empty string. You should read input till end-of-file.

The part of the code that handles input operation is already provided in the editor.

Output Format

For each case, print 'true' if the string is balanced, 'false' otherwise.

Sample Input

{}()
({()})
{}(
[]
Sample Output

true
true
false
true

   SOLUTION
   ---------
public static void main(String []argh)
{
	Scanner sc = new Scanner(System.in);
	
	while (sc.hasNext()) {
		String input=sc.next();
        System.out.println(Valid(input));
        //Complete the code
	}
}
 static boolean Valid(String s){
        Stack<Character> st = new Stack<Character>();
        int length=s.length();
        for(int i=0;i<length;i++){
        char ch = s.charAt(i);
         if(ch=='{' || ch=='(' || ch=='['){
             st.push(ch);
         }
         else if(st.isEmpty()){
             return false;
         }
         else {
             char top = st.pop();
             if((top=='{' && ch!='}')||(top=='(' && ch!=')')||(top=='[' && ch!=']'))
             return false;
         }
      } 
      return st.isEmpty();
    } 
